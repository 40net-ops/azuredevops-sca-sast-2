{
  "SchemaVersion": 2,
  "Metadata": {
    "Id": "b80d81c9-2c9a-4786-95cf-23ee94027fe2",
    "InputKind": "repository",
    "InputLocation": "/Users/jvhoof/Nextcloud/Azure/test25/jorge/insecure-app-demo",
    "InputOrigin": "jvhoof-mac",
    "CustomProperties": {
      "deployment": "local",
      "version": "0.1.78"
    },
    "Configs": {
      "CommandLine": {
        "default": {
          "sca": {
            "enabled": null,
            "pullRequest": {},
            "scan": {
              "acf": false,
              "acfLocations": 5,
              "acfLocationsFull": [],
              "exceptions": [],
              "exclude": [
                "*.spec.js",
                "*.spec.ts",
                "*.test.js",
                "*.test.ts",
                "*Test.java",
                "*Test.php",
                "*_test.go",
                "test_*.py"
              ],
              "licenseDetection": true,
              "linesOfCode": true,
              "sast": true,
              "scr": true,
              "secret": true,
              "gitHistory": false,
              "taintAnalysis": false,
              "vulnEvaluation": true,
              "activeOnly": false,
              "dynamic": false,
              "dynamicDev": false,
              "inactiveOnly": false,
              "fixSuggestions": false,
              "fullBazel": false,
              "includeDev": false,
              "javaIndirect": true,
              "javaLocalCache": true,
              "generateLockFiles": false,
              "licenseCategoriesNotAllowed": [
                "forbidden",
                "restricted"
              ],
              "pullDeps": true,
              "recurseSubmodules": false,
              "evalDirectOnly": false
            }
          },
          "iac": {
            "enabled": null,
            "pullRequest": {},
            "scan": {}
          }
        }
      },
      "Merged": {
        "default": {
          "sca": {
            "enabled": true,
            "pullRequest": {
              "auditMode": true,
              "comments": false,
              "commentOnlyHighAndCritical": false
            },
            "scan": {
              "acf": false,
              "acfLocations": 5,
              "acfLocationsFull": [],
              "exceptions": [],
              "exclude": [
                "*.spec.js",
                "*.spec.ts",
                "*.test.js",
                "*.test.ts",
                "*Test.java",
                "*Test.php",
                "*_test.go",
                "test_*.py"
              ],
              "licenseDetection": true,
              "linesOfCode": true,
              "sast": true,
              "scr": true,
              "secret": true,
              "gitHistory": false,
              "taintAnalysis": false,
              "vulnEvaluation": true,
              "activeOnly": false,
              "dynamic": false,
              "dynamicDev": false,
              "inactiveOnly": false,
              "fixSuggestions": false,
              "fullBazel": false,
              "includeDev": false,
              "javaIndirect": true,
              "javaLocalCache": true,
              "generateLockFiles": false,
              "licenseCategoriesNotAllowed": [
                "forbidden",
                "restricted"
              ],
              "pullDeps": true,
              "recurseSubmodules": false,
              "evalDirectOnly": false
            }
          },
          "iac": {
            "enabled": true,
            "pullRequest": {
              "auditMode": true,
              "comments": false,
              "commentOnlyHighAndCritical": false
            },
            "scan": {
              "scanGitSubModules": false,
              "opal": true,
              "checkov": true,
              "checkovModuleDownload": false,
              "tfsec": true,
              "terraform": true,
              "terraformPlan": true,
              "cloudformation": true,
              "helm": true,
              "awsCdk": false,
              "kubernetes": true,
              "kustomize": true,
              "dockerfile": true,
              "autofix": false,
              "exceptions": []
            }
          }
        }
      },
      "Remote": {
        "default": {
          "sca": {
            "enabled": true,
            "pullRequest": {
              "auditMode": true,
              "comments": false,
              "commentOnlyHighAndCritical": false
            },
            "scan": {
              "acf": false,
              "acfLocations": 5,
              "acfLocationsFull": [],
              "exceptions": [],
              "exclude": [
                "*.spec.js",
                "*.spec.ts",
                "*.test.js",
                "*.test.ts",
                "*Test.java",
                "*Test.php",
                "*_test.go",
                "test_*.py"
              ],
              "licenseDetection": true,
              "linesOfCode": true,
              "sast": true,
              "scr": true,
              "secret": true,
              "gitHistory": false,
              "taintAnalysis": false,
              "vulnEvaluation": true,
              "activeOnly": false,
              "dynamic": false,
              "dynamicDev": false,
              "inactiveOnly": false,
              "fixSuggestions": false,
              "fullBazel": false,
              "includeDev": false,
              "javaIndirect": true,
              "javaLocalCache": true,
              "generateLockFiles": false,
              "licenseCategoriesNotAllowed": [
                "forbidden",
                "restricted"
              ],
              "pullDeps": true,
              "recurseSubmodules": false,
              "evalDirectOnly": false
            }
          },
          "iac": {
            "enabled": true,
            "pullRequest": {
              "auditMode": true,
              "comments": false,
              "commentOnlyHighAndCritical": false
            },
            "scan": {
              "scanGitSubModules": false,
              "opal": true,
              "checkov": true,
              "checkovModuleDownload": false,
              "tfsec": true,
              "terraform": true,
              "terraformPlan": true,
              "cloudformation": true,
              "helm": true,
              "awsCdk": false,
              "kubernetes": true,
              "kustomize": true,
              "dockerfile": true,
              "autofix": false,
              "exceptions": []
            }
          }
        }
      }
    },
    "Platform": {
      "architecture": "arm64",
      "os": "darwin",
      "os.version": "15.7.2",
      "variant": "v8"
    },
    "Created": "2025-12-01T13:52:12.627255+01:00"
  },
  "RootArtifactId": "0",
  "Artifacts": [
    {
      "Id": "2",
      "Name": "requirements.txt",
      "Path": "requirements.txt",
      "Type": "pip",
      "Class": "source",
      "Language": "python",
      "Repository": "1",
      "LastEdit": "31",
      "Files": [
        ".github/workflows/forticnapp-pr.yml",
        ".github/workflows/forticnapp-push.yml",
        ".gitignore",
        "Dockerfile",
        "README",
        "README.md",
        "app/__init__.py",
        "app/main.py",
        "app/models/__init__.py",
        "app/routes/__init__.py",
        "app/routes/auth.py",
        "app/routes/form.py",
        "app/routes/upload.py",
        "app/routes/vulns.py",
        "app/routes/vulns_all.py",
        "app/routes/vulns_fixed.py",
        "app/services/__init__.py",
        "app/templates/index.html",
        "app/templates/login.html",
        "app/templates/safe_hello.html",
        "app/templates/stored_xss.html",
        "app/utils.py",
        "tools/pickle_exploit.py",
        "tools/secret_leak.sh",
        "tools/sqli_poc.sh",
        "tools/xss_poc.sh"
      ],
      "Children": [
        {
          "ArtifactId": "3",
          "Lines": [
            {
              "Start": 1,
              "End": 1
            }
          ],
          "Tags": [
            "direct"
          ],
          "LastEdit": "31",
          "PathInfo": {
            "MinDepth": 1
          }
        },
        {
          "ArtifactId": "4",
          "Lines": [
            {
              "Start": 6,
              "End": 6
            }
          ],
          "Tags": [
            "direct"
          ],
          "LastEdit": "31",
          "PathInfo": {
            "MinDepth": 1
          }
        }
      ],
      "Graph": [
        {
          "From": "2",
          "To": [
            "3",
            "4"
          ]
        }
      ],
      "DeepLicenseExpression": "Apache-2.0 AND BSD-3-Clause",
      "SimplifiedDeepLicenseExpression": "Apache-2.0 AND BSD-3-Clause",
      "DeepCopyrightString": "Copyright (C) 2010 by the pallets team.\nCopyright (C) 2010 pallets\n",
      "ShortestDependencyPaths": [
        [
          {
            "Parent": "0",
            "DependencyIndex": 0
          }
        ]
      ]
    },
    {
      "Id": "3",
      "Name": "Flask",
      "Type": "pypi",
      "Class": "pkg",
      "Language": "python",
      "Licenses": [
        {
          "Name": "BSD-3-Clause",
          "MatchType": "license",
          "Variant": "pristine.txt",
          "Confidence": 0.9483568,
          "Location": {
            "RelativePath": "examples/javascript/LICENSE",
            "Start": 5,
            "StartChar": 1,
            "End": 31,
            "EndChar": 12
          }
        },
        {
          "Name": "BSD-3-Clause",
          "MatchType": "license",
          "Variant": "pristine.txt",
          "Confidence": 0.9483568,
          "Location": {
            "RelativePath": "examples/tutorial/LICENSE",
            "Start": 5,
            "StartChar": 1,
            "End": 31,
            "EndChar": 12
          }
        },
        {
          "Name": "BSD-3-Clause",
          "MatchType": "license",
          "Variant": "pristine.txt",
          "Confidence": 1,
          "Location": {
            "RelativePath": "LICENSE.rst",
            "Start": 3,
            "StartChar": 1,
            "End": 28,
            "EndChar": 60
          }
        }
      ],
      "Copyrights": [
        {
          "Notice": "copyright 2010 pallets",
          "Location": {
            "RelativePath": "LICENSE.rst",
            "Start": 1,
            "StartChar": 1,
            "End": 1,
            "EndChar": 22
          }
        },
        {
          "Notice": "copyright 2010 by the pallets team.",
          "Location": {
            "RelativePath": "examples/javascript/LICENSE",
            "Start": 1,
            "StartChar": 1,
            "End": 1,
            "EndChar": 38
          }
        },
        {
          "Notice": "copyright 2010 by the pallets team.",
          "Location": {
            "RelativePath": "examples/tutorial/LICENSE",
            "Start": 1,
            "StartChar": 1,
            "End": 1,
            "EndChar": 38
          }
        }
      ],
      "Version": {
        "Type": "pep440",
        "Version": "1.1.1"
      },
      "Purl": "pkg:pypi/flask@1.1.1",
      "LicenseExpression": "BSD-3-Clause",
      "CopyrightString": "Copyright (C) 2010 by the pallets team.\nCopyright (C) 2010 pallets\n",
      "DeepLicenseExpression": "BSD-3-Clause",
      "SimplifiedDeepLicenseExpression": "BSD-3-Clause",
      "DeepCopyrightString": "Copyright (C) 2010 by the pallets team.\nCopyright (C) 2010 pallets\n",
      "ShortestDependencyPaths": [
        [
          {
            "Parent": "2",
            "DependencyIndex": 0
          }
        ]
      ]
    },
    {
      "Id": "0",
      "Name": "https://github.com/Jorge-lw/insecure-app-demo.git",
      "Path": "https://github.com/Jorge-lw/insecure-app-demo.git",
      "Type": "repo",
      "Class": "collection",
      "Language": "none",
      "Repository": "1",
      "Files": [
        "requirements.txt"
      ],
      "LinesOfCode": {
        "python": 362
      },
      "Children": [
        {
          "ArtifactId": "2"
        }
      ],
      "DeepLicenseExpression": "Apache-2.0 AND BSD-3-Clause",
      "SimplifiedDeepLicenseExpression": "Apache-2.0 AND BSD-3-Clause",
      "DeepCopyrightString": "Copyright (C) 2010 by the pallets team.\nCopyright (C) 2010 pallets\n"
    },
    {
      "Id": "4",
      "Name": "requests",
      "Type": "pypi",
      "Class": "pkg",
      "Language": "python",
      "Licenses": [
        {
          "Name": "Apache-2.0",
          "MatchType": "declared",
          "Variant": "a.txt",
          "Confidence": 0.9964362,
          "Location": {
            "RelativePath": "LICENSE",
            "Start": 2,
            "StartChar": 34,
            "End": 175,
            "EndChar": 66
          }
        },
        {
          "Name": "Apache-2.0",
          "MatchType": "license",
          "Variant": "a.txt",
          "Confidence": 0.9964362,
          "Location": {
            "RelativePath": "LICENSE",
            "Start": 2,
            "StartChar": 34,
            "End": 175,
            "EndChar": 66
          }
        }
      ],
      "Version": {
        "Type": "pep440",
        "Version": "2.25.1"
      },
      "Purl": "pkg:pypi/requests@2.25.1",
      "LicenseExpression": "Apache-2.0",
      "DeclaredLicenseExpression": "Apache-2.0",
      "DeepLicenseExpression": "Apache-2.0",
      "SimplifiedDeepLicenseExpression": "Apache-2.0",
      "ShortestDependencyPaths": [
        [
          {
            "Parent": "2",
            "DependencyIndex": 1
          }
        ]
      ]
    }
  ],
  "Identities": [
    {
      "Id": "30",
      "Info": {
        "Name": "jorge-juanker",
        "Email": "jorge@juanker.net"
      }
    }
  ],
  "Repositories": [
    {
      "Id": "1",
      "Info": {
        "Kind": "git",
        "Location": "https://github.com/Jorge-lw/insecure-app-demo.git",
        "Branch": "main",
        "Revision": "c4136bf63e16d02e6829eb8e0ab8806b2055fa5c",
        "Name": "jorge-juanker",
        "Email": "jorge@juanker.net",
        "Timestamp": "2025-10-23T10:42:45+02:00",
        "DefaultBranch": "main"
      },
      "Edits": [
        {
          "Id": "33",
          "Info": {
            "Time": "2025-10-20T17:59:38+02:00",
            "Revision": "8e86358b0deae2cb92eb377fbfbe455e661cdf5c",
            "Signature": "unsigned"
          },
          "AuthorId": "30"
        },
        {
          "Id": "32",
          "Info": {
            "Time": "2025-10-21T16:45:04+02:00",
            "Revision": "6e00ed560429a5f3b7152b4b2d60390956cb83e1",
            "Signature": "unsigned"
          },
          "AuthorId": "30"
        },
        {
          "Id": "31",
          "Info": {
            "Time": "2025-10-23T10:41:46+02:00",
            "Revision": "519400df1f2e884444ba7a69dbd15ba01d8ceae2",
            "Signature": "unsigned"
          },
          "AuthorId": "30"
        }
      ]
    }
  ],
  "Vulnerabilities": [
    {
      "Id": "8",
      "AffectedArtifactIds": [
        "4"
      ],
      "FixedBy": [
        "10"
      ],
      "Info": {
        "ExternalId": "CVE-2024-47081",
        "Description": "### Impact\n\nDue to a URL parsing issue, Requests releases prior to 2.32.4 may leak .netrc credentials to third parties for specific maliciously-crafted URLs.\n\n### Workarounds\nFor older versions of Requests, use of the .netrc file can be disabled with `trust_env=False` on your Requests Session ([docs](https://requests.readthedocs.io/en/latest/api/#requests.Session.trust_env)).\n\n### References\nhttps://github.com/psf/requests/pull/6965\nhttps://seclists.org/fulldisclosure/2025/Jun/2",
        "Status": "vulnerable",
        "Severity": "medium",
        "Link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-47081",
        "FixVersion": {
          "Type": "pep440",
          "Version": "2.32.4"
        },
        "CVSSv3": {
          "ExploitabilityScore": 1.6,
          "ImpactScore": 3.6,
          "Score": 5.3,
          "Vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:N/A:N",
          "Metrics": {
            "Exploitability": {
              "AttackVector": "Network",
              "AttackComplexity": "High",
              "PrivilegesRequired": "None",
              "UserInteraction": "Required"
            },
            "Scope": "Unchanged",
            "Impact": {
              "Confidentiality": "High",
              "Integrity": "None",
              "Availability": "None"
            }
          }
        }
      },
      "Fingerprint": "E1745DE5F0BA9DA3"
    },
    {
      "Id": "7",
      "AffectedArtifactIds": [
        "4"
      ],
      "FixedBy": [
        "10"
      ],
      "Info": {
        "ExternalId": "CVE-2024-35195",
        "Description": "When making requests through a Requests `Session`, if the first request is made with `verify=False` to disable cert verification, all subsequent requests to the same origin will continue to ignore cert verification regardless of changes to the value of `verify`. This behavior will continue for the lifecycle of the connection in the connection pool.\n\n### Remediation\nAny of these options can be used to remediate the current issue, we highly recommend upgrading as the preferred mitigation.\n\n* Upgrade to `requests\u003e=2.32.0`.\n* For `requests\u003c2.32.0`, avoid setting `verify=False` for the first request to a host while using a Requests Session.\n* For `requests\u003c2.32.0`, call `close()` on `Session` objects to clear existing connections if `verify=False` is used.\n\n### Related Links\n* https://github.com/psf/requests/pull/6655",
        "Status": "vulnerable",
        "Severity": "medium",
        "Link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-35195",
        "FixVersion": {
          "Type": "pep440",
          "Version": "2.32.0"
        },
        "CVSSv3": {
          "ExploitabilityScore": 0.3,
          "ImpactScore": 5.2,
          "Score": 5.6,
          "Vectors": "CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:H/I:H/A:N",
          "Metrics": {
            "Exploitability": {
              "AttackVector": "Local",
              "AttackComplexity": "High",
              "PrivilegesRequired": "High",
              "UserInteraction": "Required"
            },
            "Scope": "Unchanged",
            "Impact": {
              "Confidentiality": "High",
              "Integrity": "High",
              "Availability": "None"
            }
          }
        }
      },
      "Fingerprint": "2C1DA322802C39AA"
    },
    {
      "Id": "6",
      "AffectedArtifactIds": [
        "4"
      ],
      "FixedBy": [
        "10"
      ],
      "Info": {
        "ExternalId": "CVE-2023-32681",
        "Description": "### Impact\n\nSince Requests v2.3.0, Requests has been vulnerable to potentially leaking `Proxy-Authorization` headers to destination servers, specifically during redirects to an HTTPS origin. This is a product of how `rebuild_proxies` is used to recompute and [reattach the `Proxy-Authorization` header](https://github.com/psf/requests/blob/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773/requests/sessions.py#L319-L328) to requests when redirected. Note this behavior has _only_ been observed to affect proxied requests when credentials are supplied in the URL user information component (e.g. `https://username:password@proxy:8080`).\n\n**Current vulnerable behavior(s):**\n\n1. HTTP → HTTPS: **leak**\n2. HTTPS → HTTP: **no leak**\n3. HTTPS → HTTPS: **leak**\n4. HTTP → HTTP: **no leak**\n\nFor HTTP connections sent through the proxy, the proxy will identify the header in the request itself and remove it prior to forwarding to the destination server. However when sent over HTTPS, the `Proxy-Authorization` header must be sent in the CONNECT request as the proxy has no visibility into further tunneled requests. This results in Requests forwarding the header to the destination server unintentionally, allowing a malicious actor to potentially exfiltrate those credentials.\n\nThe reason this currently works for HTTPS connections in Requests is the `Proxy-Authorization` header is also handled by urllib3 with our usage of the ProxyManager in adapters.py with [`proxy_manager_for`](https://github.com/psf/requests/blob/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773/requests/adapters.py#L199-L235). This will compute the required proxy headers in `proxy_headers` and pass them to the Proxy Manager, avoiding attaching them directly to the Request object. This will be our preferred option going forward for default usage.\n\n### Patches\nStarting in Requests v2.31.0, Requests will no longer attach this header to redirects with an HTTPS destination. This should have no negative impacts on the default behavior of the library as the proxy credentials are already properly being handled by urllib3`s ProxyManager.\n\nFor users with custom adapters, this _may_ be potentially breaking if you were already working around this behavior. The previous functionality of `rebuild_proxies` doesn`t make sense in any case, so we would encourage any users impacted to migrate any handling of Proxy-Authorization directly into their custom adapter.\n\n### Workarounds\nFor users who are not able to update Requests immediately, there is one potential workaround.\n\nYou may disable redirects by setting `allow_redirects` to `False` on all calls through Requests top-level APIs. Note that if you`re currently relying on redirect behaviors, you will need to capture the 3xx response codes and ensure a new request is made to the redirect destination.\n```\nimport requests\nr = requests.get(`http://github.com/`, allow_redirects=False)\n```\n\n### Credits\n\nThis vulnerability was discovered and disclosed by the following individuals.\n\nDennis Brinkrolf, Haxolot (https://haxolot.com/)\nTobias Funke, (tobiasfunke93@gmail.com)",
        "Status": "vulnerable",
        "Severity": "medium",
        "Link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-32681",
        "FixVersion": {
          "Type": "pep440",
          "Version": "2.31.0"
        },
        "CVSSv3": {
          "ExploitabilityScore": 1.6,
          "ImpactScore": 4,
          "Score": 6.1,
          "Vectors": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:N/A:N",
          "Metrics": {
            "Exploitability": {
              "AttackVector": "Network",
              "AttackComplexity": "High",
              "PrivilegesRequired": "None",
              "UserInteraction": "Required"
            },
            "Scope": "Changed",
            "Impact": {
              "Confidentiality": "High",
              "Integrity": "None",
              "Availability": "None"
            }
          }
        }
      },
      "Fingerprint": "B242E27A8E2BB7F0"
    },
    {
      "Id": "5",
      "AffectedArtifactIds": [
        "3"
      ],
      "FixedBy": [
        "9"
      ],
      "Info": {
        "ExternalId": "CVE-2023-30861",
        "Description": "When all of the following conditions are met, a response containing data intended for one client may be cached and subsequently sent by a proxy to other clients. If the proxy also caches `Set-Cookie` headers, it may send one client`s `session` cookie to other clients. The severity depends on the application`s use of the session, and the proxy`s behavior regarding cookies. The risk depends on _all_ these conditions being met.\n\n1. The application must be hosted behind a caching proxy that does not strip cookies or ignore responses with cookies.\n2. The application sets [`session.permanent = True`](https://flask.palletsprojects.com/en/2.3.x/api/#flask.session.permanent).\n2. The application does not access or modify the session at any point during a request.\n4. [`SESSION_REFRESH_EACH_REQUEST`](https://flask.palletsprojects.com/en/2.3.x/config/#SESSION_REFRESH_EACH_REQUEST) is enabled (the default).\n5. The application does not set a `Cache-Control` header to indicate that a page is private or should not be cached.\n\nThis happens because vulnerable versions of Flask only set the `Vary: Cookie` header when the session is accessed or modified, not when it is refreshed (re-sent to update the expiration) without being accessed or modified.",
        "Status": "vulnerable",
        "Severity": "high",
        "Link": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-30861",
        "FixVersion": {
          "Type": "pep440",
          "Version": "2.3.2"
        },
        "CVSSv3": {
          "ExploitabilityScore": 3.9,
          "ImpactScore": 3.6,
          "Score": 7.5,
          "Vectors": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
          "Metrics": {
            "Exploitability": {
              "AttackVector": "Network",
              "AttackComplexity": "Low",
              "PrivilegesRequired": "None",
              "UserInteraction": "None"
            },
            "Scope": "Unchanged",
            "Impact": {
              "Confidentiality": "High",
              "Integrity": "None",
              "Availability": "None"
            }
          }
        }
      },
      "Fingerprint": "AE9B1648A4D0BD22"
    }
  ],
  "Weaknesses": [
    {
      "Id": "22",
      "Info": {
        "ExternalId": "CWE-95",
        "CWEInfo": {
          "Name": "Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')",
          "WeaknessAbstraction": "Variant",
          "Status": "Incomplete",
          "Description": "The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. eval).",
          "ExtendedDescription": "This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:94:VIEW ID:1000:ORDINAL:Primary::",
          "WeaknessOrdinalities": "::ORDINALITY:Primary::",
          "ApplicablePlatforms": "::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:JavaScript:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Python:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Perl:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Ruby:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Interpreted:LANGUAGE PREVALENCE:Undetermined::",
          "ModesOfIntroduction": "::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Implementation:NOTE:This weakness is prevalent in handler/dispatch procedures that might want to invoke a large number of functions, or set a large number of variables.::",
          "CommonConsequences": "::SCOPE:Confidentiality:IMPACT:Read Files or Directories:IMPACT:Read Application Data:NOTE:The injected code could access restricted data / files.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:In some cases, injectable code controls authentication; this may lead to a remote vulnerability.::SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:NOTE:Injected code can access resources that the attacker is directly prevented from accessing.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Other:IMPACT:Execute Unauthorized Code or Commands:NOTE:Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:Often the actions performed by injected control code are unlogged.::",
          "DetectionMethods": "::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::",
          "PotentialMitigations": "::PHASE:Architecture and Design Implementation:DESCRIPTION:If possible, refactor your code so that it does not need to use eval() at all.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Implementation:DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.::",
          "ObservedExamples": "::REFERENCE:CVE-2022-2054:DESCRIPTION:Python compiler uses eval() to execute malicious strings as Python code.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-2054::REFERENCE:CVE-2021-22204:DESCRIPTION:Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22204::REFERENCE:CVE-2021-22205:DESCRIPTION:Chain: backslash followed by a newline can bypass a validation step (CWE-20), leading to eval injection (CWE-95), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22205::REFERENCE:CVE-2008-5071:DESCRIPTION:Eval injection in PHP program.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5071::REFERENCE:CVE-2002-1750:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1750::REFERENCE:CVE-2008-5305:DESCRIPTION:Eval injection in Perl program using an ID that should only contain hyphens and numbers.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5305::REFERENCE:CVE-2002-1752:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1752::REFERENCE:CVE-2002-1753:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1753::REFERENCE:CVE-2005-1527:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1527::REFERENCE:CVE-2005-2837:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2837::REFERENCE:CVE-2005-1921:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1921::REFERENCE:CVE-2005-2498:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2498::REFERENCE:CVE-2005-3302:DESCRIPTION:Code injection into Python eval statement from a field in a formatted file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3302::REFERENCE:CVE-2007-1253:DESCRIPTION:Eval injection in Python program.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1253::REFERENCE:CVE-2001-1471:DESCRIPTION:chain: Resultant eval injection. An invalid value prevents initialization of variables, which can be modified by attacker and later injected into PHP eval statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1471::REFERENCE:CVE-2007-2713:DESCRIPTION:Chain: Execution after redirect triggers eval injection.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-2713::",
          "TaxonomyMappings": "::TAXONOMY NAME:PLOVER:ENTRY NAME:Direct Dynamic Code Evaluation ('Eval Injection')::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A3:ENTRY NAME:Malicious File Execution:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS35-PL:ENTRY NAME:Do not invoke the eval form with a string argument:MAPPING FIT:Exact::",
          "RelatedAttackPatterns": "::35::",
          "Notes": "::TYPE:Other:NOTE:Factors: special character errors can play a role in increasing the variety of code that can be injected, although some vulnerabilities do not require special characters at all, e.g. when a single function without arguments can be referenced and a terminator character is not necessary.::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/95.html"
      },
      "Rules": [
        {
          "Id": "user-input-in-eval-command-python",
          "DisplayName": "user-input-in-eval-command-python",
          "ShortDescription": "User input in eval command",
          "FullDescription": "Detected user input in eval command which is a bad practice and may allow eval injection attacks.",
          "Precision": "low",
          "ExtraData": {
            "defaultConfigurationLevel": "high",
            "remediationRecommendation": "Avoid using eval command with direct user input and, instead, use text constructs with pre-established bound values for each argument parameter",
            "secretCategory": ""
          }
        }
      ],
      "Instances": [
        {
          "Id": "23",
          "RuleId": "user-input-in-eval-command-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "high",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 173,
                "StartChar": 5,
                "End": 175,
                "EndChar": 5
              },
              "TextSnippet": "# ------------------------------------------------------\n@bp.route(\"/eval\", methods=[\"POST\"])\ndef code_eval():\n    expr = request.form.get(\"expr\", \"\")\n    # Vulnerable: direct eval of user input\n    result = eval(expr)\n    return jsonify({\"expr\": expr, \"result\": repr(result)})\n\n# ------------------------------------------------------\n# CWE-434 Unrestricted File Upload (no validation)\n# - allowed in file_upload above; also show a dedicated endpoint checking extension (missing)",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected user input in eval command which is a bad practice and may allow eval injection attacks."
          },
          "Fingerprint": "6113A24C36EF68D4"
        }
      ]
    },
    {
      "Id": "13",
      "Info": {
        "ExternalId": "CWE-1275",
        "CWEInfo": {
          "Name": "Sensitive Cookie with Improper SameSite Attribute",
          "WeaknessAbstraction": "Variant",
          "Status": "Incomplete",
          "Description": "The SameSite attribute for sensitive cookies is not set, or an insecure value is used.",
          "ExtendedDescription": "The SameSite attribute controls how cookies are sent for cross-domain requests. This attribute may have three values: 'Lax', 'Strict', or 'None'. If the 'None' value is used, a website may create a cross-domain POST HTTP request to another website, and the browser automatically adds cookies to this request. This may lead to Cross-Site-Request-Forgery (CSRF) attacks if there are no additional protections in place (such as Anti-CSRF tokens).",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:923:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:352:VIEW ID:1000::",
          "ApplicablePlatforms": "::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Web Based:TECHNOLOGY PREVALENCE:Undetermined::",
          "ModesOfIntroduction": "::PHASE:Implementation:NOTE:This weakness occurs during implementation when the coder does not properly set the SameSite attribute.::",
          "CommonConsequences": "::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Non-Repudiation:SCOPE:Access Control:IMPACT:Modify Application Data:LIKELIHOOD:Low:NOTE:If the website does not impose additional defense against CSRF attacks, failing to use the 'Lax' or 'Strict' values could increase the risk of exposure to CSRF attacks. The likelihood of the integrity breach is Low because a successful attack does not only depend on an insecure SameSite attribute. In order to perform a CSRF attack there are many conditions that must be met, such as the lack of CSRF tokens, no confirmations for sensitive actions on the website, a simple Content-Type header in the HTTP request and many more.::",
          "DetectionMethods": "::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::",
          "PotentialMitigations": "::PHASE:Implementation:DESCRIPTION:Set the SameSite attribute of a sensitive cookie to 'Lax' or 'Strict'. This instructs the browser to apply this cookie only to same-domain requests, which provides a good Defense in Depth against CSRF attacks. When the 'Lax' value is in use, cookies are also sent for top-level cross-domain navigation via HTTP GET, HEAD, OPTIONS, and TRACE methods, but not for other HTTP methods that are more like to cause side-effects of state mutation.:EFFECTIVENESS:High::",
          "ObservedExamples": "::REFERENCE:CVE-2022-24045:DESCRIPTION:Web application for a room automation system has client-side JavaScript that sets a sensitive cookie without the SameSite security attribute, allowing the cookie to be sniffed:LINK:https://www.cve.org/CVERecord?id=CVE-2022-24045::",
          "RelatedAttackPatterns": "::62::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/1275.html"
      },
      "Rules": [
        {
          "Id": "cookie-with-improper-samesite-attr-in-flask-python",
          "DisplayName": "cookie-with-improper-samesite-attr-in-flask-python",
          "ShortDescription": "Cookie with improper samesite attr in flask",
          "FullDescription": "Detected cookie with improper value at the samesite attribute, which is a bad practice and may allow Cross-Site-Request-Forgery (CSRF) attacks",
          "Precision": "high",
          "ExtraData": {
            "defaultConfigurationLevel": "medium",
            "remediationRecommendation": "Consider setting the 'samesite' argument of the 'set_cookie' method to 'Lax' or 'Strict' to prevent CSRF attacks, unless you know what you are doing",
            "secretCategory": ""
          }
        }
      ],
      "Instances": [
        {
          "Id": "14",
          "RuleId": "cookie-with-improper-samesite-attr-in-flask-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "medium",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/auth.py",
                "Start": 16,
                "StartChar": 9,
                "End": 16,
                "EndChar": 44
              },
              "LastEdit": "32"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/auth.py",
                "Start": 17,
                "StartChar": 9,
                "End": 17,
                "EndChar": 88
              },
              "LastEdit": "32"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/auth.py",
                "Start": 17,
                "StartChar": 9,
                "End": 17,
                "EndChar": 9
              },
              "TextSnippet": "    pwd = request.form.get('password')\n    if USERS.get(username) == pwd:\n        # insecure cookie: no HttpOnly, no Secure, signed with hardcoded secret above\n        resp = make_response(redirect('/'))\n        resp.set_cookie('demo_auth', f\"{username}|token\", httponly=False, secure=False)\n        return resp\n    return \"Invalid\", 401\n\n@bp.route('/profile')\ndef profile():",
              "LastEdit": "32"
            }
          ],
          "ExtraData": {
            "message": "Detected cookie with improper value at the samesite attribute, which is a bad practice and may allow Cross-Site-Request-Forgery (CSRF) attacks"
          },
          "Fingerprint": "30EDF3C869FB238F"
        }
      ]
    },
    {
      "Id": "24",
      "Info": {
        "ExternalId": "CWE-328",
        "CWEInfo": {
          "Name": "Use of Weak Hash",
          "WeaknessAbstraction": "Base",
          "Status": "Draft",
          "Description": "The product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).",
          "ExtendedDescription": "A hash function is defined as an algorithm that maps arbitrarily sized data into a fixed-sized digest (output) such that the following properties hold: 1. The algorithm is not invertible (also called one-way or not reversible) 2. The algorithm is deterministic; the same input produces the same digest every time Building on this definition, a cryptographic hash function must also ensure that a malicious actor cannot leverage the hash function to have a reasonable chance of success at determining any of the following: 1. the original input (preimage attack), given only the digest 2. another input that can produce the same digest (2nd preimage attack), given the original input 3. a set of two or more inputs that evaluate to the same digest (birthday attack), given the actor can arbitrarily choose the inputs to be hashed and can do so a reasonable amount of times What is regarded as reasonable varies by context and threat model, but in general, reasonable could cover any attack that is more efficient than brute force (i.e., on average, attempting half of all possible combinations). Note that some attacks might be more efficient than brute force but are still not regarded as achievable in the real world. Any algorithm does not meet the above conditions will generally be considered weak for general use in hashing. In addition to algorithmic weaknesses, a hash function can be made weak by using the hash in a security context that breaks its security guarantees. For example, using a hash function without a salt for storing passwords (that are sufficiently short) could enable an adversary to create a rainbow table [REF-637] to recover the password under certain conditions; this attack works against such hash functions as MD5, SHA-1, and SHA-2.",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:326:VIEW ID:1000::NATURE:ChildOf:CWE ID:327:VIEW ID:1000:ORDINAL:Primary::",
          "ApplicablePlatforms": "::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::",
          "ModesOfIntroduction": "::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::",
          "CommonConsequences": "::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism::",
          "DetectionMethods": "::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::",
          "PotentialMitigations": "::PHASE:Architecture and Design:DESCRIPTION:Use an adaptive hash function that can be configured to change the amount of computational effort needed to compute the hash, such as the number of iterations (stretching) or the amount of memory required. Some hash functions perform salting automatically. These functions can significantly increase the overhead for a brute force attack compared to intentionally-fast functions such as MD5. For example, rainbow table attacks can become infeasible due to the high computing overhead. Finally, since computing power gets faster and cheaper over time, the technique can be reconfigured to increase the workload without forcing an entire replacement of the algorithm in use. Some hash functions that have one or more of these desired properties include bcrypt [REF-291], scrypt [REF-292], and PBKDF2 [REF-293]. While there is active debate about which of these is the most effective, they are all stronger than using salts with hash functions with very little computing overhead. Note that using these functions can have an impact on performance, so they require special consideration to avoid denial-of-service attacks. However, their configurability provides finer control over how much CPU and memory is used, so it could be adjusted to suit the environment's needs.:EFFECTIVENESS:High::",
          "ObservedExamples": "::REFERENCE:CVE-2022-30320:DESCRIPTION:Programmable Logic Controller (PLC) uses a protocol with a cryptographically insecure hashing algorithm for passwords.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30320::REFERENCE:CVE-2005-4900:DESCRIPTION:SHA-1 algorithm is not collision-resistant.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-4900::REFERENCE:CVE-2020-25685:DESCRIPTION:DNS product uses a weak hash (CRC32 or SHA-1) of the query name, allowing attacker to forge responses by computing domain names with the same hash.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-25685::REFERENCE:CVE-2012-6707:DESCRIPTION:blogging product uses MD5-based algorithm for passwords.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-6707::REFERENCE:CVE-2019-14855:DESCRIPTION:forging of certificate signatures using SHA-1 collisions.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-14855::REFERENCE:CVE-2017-15999:DESCRIPTION:mobile app for backup sends SHA-1 hash of password in cleartext.:LINK:https://www.cve.org/CVERecord?id=CVE-2017-15999::REFERENCE:CVE-2006-4068:DESCRIPTION:Hard-coded hashed values for username and password contained in client-side script, allowing brute-force offline attacks.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4068::",
          "TaxonomyMappings": "::TAXONOMY NAME:PLOVER:ENTRY NAME:Reversible One-Way Hash::",
          "RelatedAttackPatterns": "::461::68::",
          "Notes": "::TYPE:Maintenance:NOTE:Since CWE 4.4, various cryptography-related entries including CWE-328 have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/328.html"
      },
      "Rules": [
        {
          "Id": "insecure-md5-in-hashlib-python",
          "DisplayName": "insecure-md5-in-hashlib-python",
          "ShortDescription": "Insecure md5 in hashlib",
          "FullDescription": "Detected use of weak MD5 hash function, which should be avoided when there are security implications",
          "Precision": "high",
          "ExtraData": {
            "defaultConfigurationLevel": "medium",
            "remediationRecommendation": "Consider using a stronger hash function such as SHA-256",
            "secretCategory": ""
          }
        }
      ],
      "Instances": [
        {
          "Id": "25",
          "RuleId": "insecure-md5-in-hashlib-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "medium",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 198,
                "StartChar": 9,
                "End": 198,
                "EndChar": 9
              },
              "TextSnippet": "def weak_hash():\n    pwd = request.form.get(\"password\", \"\")\n    # Vulnerable: usage of MD5 for password hashing\n    h = hashlib.md5(pwd.encode()).hexdigest()\n    return jsonify({\"md5\": h})\n\n# ------------------------------------------------------\n# CWE-200 Information Exposure\n# - returns internal config / secrets (hardcoded)",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected use of weak MD5 hash function, which should be avoided when there are security implications"
          },
          "Fingerprint": "7EF4072F83FAE67E"
        }
      ]
    },
    {
      "Id": "18",
      "Info": {
        "ExternalId": "CWE-776",
        "CWEInfo": {
          "Name": "Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')",
          "WeaknessAbstraction": "Base",
          "Status": "Draft",
          "Description": "The product uses XML documents and allows their structure to be defined with a Document Type Definition (DTD), but it does not properly control the number of recursive definitions of entities.",
          "ExtendedDescription": "If the DTD contains a large number of nested or recursive entities, this can lead to explosive growth of data when parsed, causing a denial of service.",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:674:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:674:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:405:VIEW ID:1000::",
          "ApplicablePlatforms": "::LANGUAGE NAME:XML:LANGUAGE PREVALENCE:Undetermined::",
          "AlternateTerms": "::TERM:XEE:DESCRIPTION:XEE is the acronym commonly used for XML Entity Expansion.::TERM:Billion Laughs Attack::TERM:XML Bomb:DESCRIPTION:While the XML Bomb term was used in the early years of knowledge of this issue, the XEE term seems to be more commonly used.::",
          "ModesOfIntroduction": "::PHASE:Implementation::PHASE:Operation::",
          "CommonConsequences": "::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Other):NOTE:If parsed, recursive entity references allow the attacker to expand data exponentially, quickly consuming all system resources.::",
          "DetectionMethods": "::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect sources (origins of input) with sinks (destinations where the data interacts with external components, a lower layer such as the OS, etc.):EFFECTIVENESS:High::",
          "PotentialMitigations": "::PHASE:Operation:DESCRIPTION:If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.::PHASE:Implementation:DESCRIPTION:Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.::",
          "ObservedExamples": "::REFERENCE:CVE-2008-3281:DESCRIPTION:XEE in XML-parsing library.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3281::REFERENCE:CVE-2011-3288:DESCRIPTION:XML bomb / XEE in enterprise communication product.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-3288::REFERENCE:CVE-2011-1755:DESCRIPTION:Billion laughs attack in XMPP server daemon.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1755::REFERENCE:CVE-2009-1955:DESCRIPTION:XML bomb in web server module:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1955::REFERENCE:CVE-2003-1564:DESCRIPTION:Parsing library allows XML bomb:LINK:https://www.cve.org/CVERecord?id=CVE-2003-1564::",
          "TaxonomyMappings": "::TAXONOMY NAME:WASC:ENTRY ID:44:ENTRY NAME:XML Entity Expansion::",
          "RelatedAttackPatterns": "::197::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/776.html"
      },
      "Rules": [
        {
          "Id": "insecure-xml-parser-python",
          "DisplayName": "insecure-xml-parser-python",
          "ShortDescription": "Insecure xml parser",
          "FullDescription": "Detected use of XML parser with known Document Type Definition (DTD) vulnerabilities, which may allow Denial-of-Service (DoS) attacks",
          "Precision": "high",
          "ExtraData": {
            "defaultConfigurationLevel": "medium",
            "remediationRecommendation": "Use a secure XML parser such as defusedxml (see: https://docs.python.org/3/library/xml.html#defusedxml-package)",
            "secretCategory": ""
          }
        }
      ],
      "Instances": [
        {
          "Id": "19",
          "RuleId": "insecure-xml-parser-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "medium",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 8,
                "StartChar": 1,
                "End": 8,
                "EndChar": 1
              },
              "TextSnippet": "import pickle\nimport subprocess\nimport hashlib\nimport xml.etree.ElementTree as ET   # used to demonstrate XXE if misused\nimport requests\nfrom flask import Blueprint, request, jsonify, render_template_string, redirect, send_from_directory\n\nbp = Blueprint(\"vulns_all\", __name__)\n",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected use of XML parser with known Document Type Definition (DTD) vulnerabilities, which may allow Denial-of-Service (DoS) attacks"
          },
          "Fingerprint": "2DA9F1A85A52A183"
        }
      ]
    },
    {
      "Id": "15",
      "Info": {
        "ExternalId": "CWE-89",
        "CWEInfo": {
          "Name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
          "WeaknessAbstraction": "Base",
          "Status": "Stable",
          "Description": "The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",
          "ExtendedDescription": "Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands. SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or product package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:943:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::",
          "ApplicablePlatforms": "::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Undetermined::",
          "ModesOfIntroduction": "::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Implementation:NOTE:This weakness typically appears in data-rich applications that save user inputs in a database.::",
          "CommonConsequences": "::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.::SCOPE:Integrity:IMPACT:Modify Application Data:NOTE:Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.::",
          "DetectionMethods": "::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Database Scanners Cost effective for partial coverage: Web Application Scanner Web Services Scanner:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",
          "PotentialMitigations": "::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.::PHASE:Architecture and Design:STRATEGY:Parameterization:DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::",
          "ObservedExamples": "::REFERENCE:CVE-2021-42258:DESCRIPTION:SQL injection in time and billing software, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-42258::REFERENCE:CVE-2021-27101:DESCRIPTION:SQL injection in file-transfer system via a crafted Host header, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-27101::REFERENCE:CVE-2020-12271:DESCRIPTION:SQL injection in firewall product's admin interface or user portal, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-12271::REFERENCE:CVE-2019-3792:DESCRIPTION:An automation system written in Go contains an API that is vulnerable to SQL injection allowing the attacker to read privileged data.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-3792::REFERENCE:CVE-2004-0366:DESCRIPTION:chain: SQL injection in library intended for database authentication allows SQL injection and authentication bypass.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0366::REFERENCE:CVE-2008-2790:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2790::REFERENCE:CVE-2008-2223:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2223::REFERENCE:CVE-2007-6602:DESCRIPTION:SQL injection via user name.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6602::REFERENCE:CVE-2008-5817:DESCRIPTION:SQL injection via user name or password fields.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5817::REFERENCE:CVE-2003-0377:DESCRIPTION:SQL injection in security product, using a crafted group name.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0377::REFERENCE:CVE-2008-2380:DESCRIPTION:SQL injection in authentication library.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2380::REFERENCE:CVE-2017-11508:DESCRIPTION:SQL injection in vulnerability management and reporting tool, using a crafted password.:LINK:https://www.cve.org/CVERecord?id=CVE-2017-11508::",
          "TaxonomyMappings": "::TAXONOMY NAME:PLOVER:ENTRY NAME:SQL injection::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:SQL Injection::TAXONOMY NAME:CLASP:ENTRY NAME:SQL injection::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:19:ENTRY NAME:SQL Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-89::TAXONOMY NAME:SEI CERT Oracle Coding Standard for Java:ENTRY ID:IDS00-J:ENTRY NAME:Prevent SQL injection:MAPPING FIT:Exact::",
          "RelatedAttackPatterns": "::108::109::110::470::66::7::",
          "Notes": "::TYPE:Relationship:NOTE:SQL injection can be resultant from special character mismanagement, MAID, or denylist/allowlist problems. It can be primary to authentication errors.::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/89.html"
      },
      "Rules": [
        {
          "Id": "string-concat-in-sql-command-in-sqlite3-python",
          "DisplayName": "string-concat-in-sql-command-in-sqlite3-python",
          "ShortDescription": "String concat in sql command in sqlite3",
          "FullDescription": "Detected string concatenation in SQL command, which is a bad practice and may allow SQL injection attacks",
          "Precision": "medium",
          "ExtraData": {
            "defaultConfigurationLevel": "high",
            "remediationRecommendation": "Use the 'sqlite3_prepare' santization framework for text constructs and pre-establish the approproate bound values for each argument parameter",
            "secretCategory": ""
          }
        }
      ],
      "Instances": [
        {
          "Id": "20",
          "RuleId": "string-concat-in-sql-command-in-sqlite3-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "high",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 53,
                "StartChar": 11,
                "End": 53,
                "EndChar": 81
              },
              "LastEdit": "31"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 54,
                "StartChar": 5,
                "End": 54,
                "EndChar": 19
              },
              "LastEdit": "31"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 54,
                "StartChar": 5,
                "End": 54,
                "EndChar": 5
              },
              "TextSnippet": "    conn = sqlite3.connect(DB)\n    c = conn.cursor()\n    # Vulnerable: direct string formatting -\u003e SQL Injection\n    sql = f\"INSERT INTO messages (name, message) VALUES ('{name}', '{message}')\"\n    c.execute(sql)\n    conn.commit()\n    conn.close()\n    return redirect(\"/xss/stored/list\")\n\n@bp.route(\"/xss/stored/list\", methods=[\"GET\"])",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected string concatenation in SQL command, which is a bad practice and may allow SQL injection attacks"
          },
          "Fingerprint": "57046B3EA39D0446"
        },
        {
          "Id": "21",
          "RuleId": "string-concat-in-sql-command-in-sqlite3-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "high",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 81,
                "StartChar": 15,
                "End": 81,
                "EndChar": 56
              },
              "LastEdit": "31"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 81,
                "StartChar": 5,
                "End": 81,
                "EndChar": 57
              },
              "LastEdit": "31"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 81,
                "StartChar": 5,
                "End": 81,
                "EndChar": 5
              },
              "TextSnippet": "    # perform deletion (insecure demo)\n    conn = sqlite3.connect(DB)\n    c = conn.cursor()\n    c.execute(f\"DELETE FROM users WHERE id = {user_id}\")\n    conn.commit()\n    conn.close()\n    return jsonify({\"deleted_user\": user_id})\n\n# ------------------------------------------------------",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected string concatenation in SQL command, which is a bad practice and may allow SQL injection attacks"
          },
          "Fingerprint": "57046B3EA39D0446"
        },
        {
          "Id": "26",
          "RuleId": "string-concat-in-sql-command-in-sqlite3-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "high",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 221,
                "StartChar": 15,
                "End": 221,
                "EndChar": 75
              },
              "LastEdit": "31"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 221,
                "StartChar": 5,
                "End": 221,
                "EndChar": 76
              },
              "LastEdit": "31"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 221,
                "StartChar": 5,
                "End": 221,
                "EndChar": 5
              },
              "TextSnippet": "    conn = sqlite3.connect(DB)\n    c = conn.cursor()\n    # vulnerable: direct id-based access without ownership/auth checks\n    c.execute(f\"SELECT id, owner_id, note FROM notes WHERE id = {note_id}\")\n    row = c.fetchone()\n    conn.close()\n    if not row:\n        return jsonify({\"error\": \"not found\"}), 404\n    return jsonify({\"note\": row})",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected string concatenation in SQL command, which is a bad practice and may allow SQL injection attacks"
          },
          "Fingerprint": "57046B3EA39D0446"
        },
        {
          "Id": "17",
          "RuleId": "string-concat-in-sql-command-in-sqlite3-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "high",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns.py",
                "Start": 31,
                "StartChar": 11,
                "End": 31,
                "EndChar": 76
              },
              "LastEdit": "33"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns.py",
                "Start": 34,
                "StartChar": 16,
                "End": 34,
                "EndChar": 30
              },
              "LastEdit": "33"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns.py",
                "Start": 34,
                "StartChar": 16,
                "End": 34,
                "EndChar": 16
              },
              "TextSnippet": "    # vulnerable: direct string formatting into SQL\n    conn = sqlite3.connect(DB_PATH)\n    c = conn.cursor()\n    sql = f\"SELECT id, username, secret FROM users WHERE username = '{q}';\"\n    # return the raw SQL and the result (makes it obvious in demo)\n    try:\n        rows = c.execute(sql).fetchall()\n    except Exception as e:\n        return jsonify({\"error\": str(e), \"sql\": sql}), 400\n    conn.close()\n    return jsonify({\"sql\": sql, \"rows\": rows})\n",
              "LastEdit": "33"
            }
          ],
          "ExtraData": {
            "message": "Detected string concatenation in SQL command, which is a bad practice and may allow SQL injection attacks"
          },
          "Fingerprint": "AE8B5C33893B3916"
        },
        {
          "Id": "16",
          "RuleId": "string-concat-in-sql-command-in-sqlite3-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "high",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/form.py",
                "Start": 33,
                "StartChar": 11,
                "End": 33,
                "EndChar": 81
              },
              "LastEdit": "32"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/form.py",
                "Start": 34,
                "StartChar": 5,
                "End": 34,
                "EndChar": 19
              },
              "LastEdit": "32"
            },
            {
              "LineLocation": {
                "RelativePath": "app/routes/form.py",
                "Start": 34,
                "StartChar": 5,
                "End": 34,
                "EndChar": 5
              },
              "TextSnippet": "    # Vulnerable: direct SQL string building -\u003e SQLi\n    conn = sqlite3.connect(DB)\n    c = conn.cursor()\n    sql = f\"INSERT INTO messages (name, message) VALUES ('{name}', '{message}')\"\n    c.execute(sql)\n    conn.commit()\n    conn.close()\n    return redirect(url_for('form.messages'))\n\n@bp.route('/messages', methods=['GET'])",
              "LastEdit": "32"
            }
          ],
          "ExtraData": {
            "message": "Detected string concatenation in SQL command, which is a bad practice and may allow SQL injection attacks"
          },
          "Fingerprint": "24F5D0E5D252D086"
        }
      ]
    },
    {
      "Id": "27",
      "Info": {
        "ExternalId": "CWE-346",
        "CWEInfo": {
          "Name": "Origin Validation Error",
          "WeaknessAbstraction": "Class",
          "Status": "Draft",
          "Description": "The product does not properly verify that the source of data or communication is valid.",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:345:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:345:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:284:VIEW ID:1000::",
          "WeaknessOrdinalities": "::ORDINALITY:Primary::ORDINALITY:Resultant::",
          "ApplicablePlatforms": "::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::",
          "ModesOfIntroduction": "::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::",
          "CommonConsequences": "::SCOPE:Access Control:SCOPE:Other:IMPACT:Gain Privileges or Assume Identity:IMPACT:Varies by Context:NOTE:An attacker can access any functionality that is inadvertently accessible to the source.::",
          "ObservedExamples": "::REFERENCE:CVE-2000-1218:DESCRIPTION:DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning:LINK:https://www.cve.org/CVERecord?id=CVE-2000-1218::REFERENCE:CVE-2005-0877:DESCRIPTION:DNS server can accept DNS updates from hosts that it did not query, leading to cache poisoning:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0877::REFERENCE:CVE-2001-1452:DESCRIPTION:DNS server caches glue records received from non-delegated name servers:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1452::REFERENCE:CVE-2005-2188:DESCRIPTION:user ID obtained from untrusted source (URL):LINK:https://www.cve.org/CVERecord?id=CVE-2005-2188::REFERENCE:CVE-2003-0174:DESCRIPTION:LDAP service does not verify if a particular attribute was set by the LDAP server:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0174::REFERENCE:CVE-1999-1549:DESCRIPTION:product does not sufficiently distinguish external HTML from internal, potentially dangerous HTML, allowing bypass using special strings in the page title. Overlaps special elements.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-1549::REFERENCE:CVE-2003-0981:DESCRIPTION:product records the reverse DNS name of a visitor in the logs, allowing spoofing and resultant XSS.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0981::",
          "TaxonomyMappings": "::TAXONOMY NAME:PLOVER:ENTRY NAME:Origin Validation Error::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR2.12 RE(1)::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SD-1::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SR-2::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-1:ENTRY NAME:Req SVV-1::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR2.12 RE(1)::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR3.1 RE(1)::",
          "RelatedAttackPatterns": "::111::141::142::160::21::384::385::386::387::388::510::59::60::75::76::89::",
          "Notes": "::TYPE:Maintenance:NOTE:This entry has some significant overlap with other CWE entries and may need some clarification. See terminology notes.::TYPE:Terminology:NOTE:The Origin Validation Error term was originally used in a 1995 thesis [REF-324]. Although not formally defined, an issue is considered to be an origin validation error if either (1) an object [accepts] input from an unauthorized subject, or (2) the system [fails] to properly or completely authenticate a subject. A later section says that an origin validation error can occur when the system (1) does not properly authenticate a user or process or (2) does not properly authenticate the shared data or libraries. The only example provided in the thesis (covered by OSVDB:57615) involves a setuid program running command-line arguments without dropping privileges. So, this definition (and its examples in the thesis) effectively cover other weaknesses such as CWE-287 (Improper Authentication), CWE-285 (Improper Authorization), and CWE-250 (Execution with Unnecessary Privileges). There appears to be little usage of this term today, except in the SecurityFocus vulnerability database, where the term is used for a variety of issues, including web-browser problems that allow violation of the Same Origin Policy and improper validation of the source of an incoming message.::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/346.html"
      },
      "Rules": [
        {
          "Id": "overly-permissive-origin-in-django-python",
          "DisplayName": "overly-permissive-origin-in-django-python",
          "ShortDescription": "Overly permissive origin in django",
          "FullDescription": "Detected an overly permissive origin (CORS) policy, which is a bad practice and may allow cross-origin attacks that expose private data to malicious actors.",
          "Precision": "high",
          "ExtraData": {
            "defaultConfigurationLevel": "medium",
            "remediationRecommendation": "Consider enforcing an explicit Cross-Origin-Resource-Sharing (CORS) policy by setting the 'Access-Control-Allow-Origin' value so that it only allows specific origins",
            "secretCategory": ""
          }
        },
        {
          "Id": "overly-permissive-origin-in-flask-python",
          "DisplayName": "overly-permissive-origin-in-flask-python",
          "ShortDescription": "Overly permissive origin in flask",
          "FullDescription": "Detected an overly permissive origin (CORS) policy, which is a bad practice and may allow cross-origin attacks that expose private data to malicious actors.",
          "Precision": "high",
          "ExtraData": {
            "defaultConfigurationLevel": "medium",
            "remediationRecommendation": "Consider enforcing an explicit Cross-Origin-Resource-Sharing (CORS) policy by setting the 'Access-Control-Allow-Origin' value so that it only allows specific origins",
            "secretCategory": ""
          }
        }
      ],
      "Instances": [
        {
          "Id": "28",
          "RuleId": "overly-permissive-origin-in-flask-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "medium",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 235,
                "StartChar": 5,
                "End": 235,
                "EndChar": 5
              },
              "TextSnippet": "@bp.route(\"/cors/open\", methods=[\"GET\"])\ndef cors_open():\n    resp = jsonify({\"status\": \"CORS open to all origins\"})\n    resp.headers[\"Access-Control-Allow-Origin\"] = \"*\"\n    return resp\n\n# ------------------------------------------------------\n# CWE-306 Missing Authentication\n# - a sensitive action endpoint that does not verify the user",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected an overly permissive origin (CORS) policy, which is a bad practice and may allow cross-origin attacks that expose private data to malicious actors."
          },
          "Fingerprint": "DDC9DD23DAF9EFF7"
        },
        {
          "Id": "29",
          "RuleId": "overly-permissive-origin-in-django-python",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "medium",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/routes/vulns_all.py",
                "Start": 235,
                "StartChar": 5,
                "End": 235,
                "EndChar": 5
              },
              "TextSnippet": "@bp.route(\"/cors/open\", methods=[\"GET\"])\ndef cors_open():\n    resp = jsonify({\"status\": \"CORS open to all origins\"})\n    resp.headers[\"Access-Control-Allow-Origin\"] = \"*\"\n    return resp\n\n# ------------------------------------------------------\n# CWE-306 Missing Authentication\n# - a sensitive action endpoint that does not verify the user",
              "LastEdit": "31"
            }
          ],
          "ExtraData": {
            "message": "Detected an overly permissive origin (CORS) policy, which is a bad practice and may allow cross-origin attacks that expose private data to malicious actors."
          },
          "Fingerprint": "59C05B6F65DEBA4B"
        }
      ]
    },
    {
      "Id": "11",
      "Info": {
        "ExternalId": "CWE-798",
        "CWEInfo": {
          "Name": "Use of Hard-coded Credentials",
          "WeaknessAbstraction": "Base",
          "Status": "Draft",
          "Description": "The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.",
          "ExtendedDescription": "Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the product administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the product contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. Outbound: the product connects to another system or component, and it contains hard-coded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.",
          "RelatedWeaknesses": "::NATURE:ChildOf:CWE ID:1391:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:287:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:344:VIEW ID:1000::NATURE:ChildOf:CWE ID:671:VIEW ID:1000::NATURE:PeerOf:CWE ID:257:VIEW ID:1000::",
          "WeaknessOrdinalities": "::ORDINALITY:Primary::",
          "ApplicablePlatforms": "::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::",
          "ModesOfIntroduction": "::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::",
          "CommonConsequences": "::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Read Application Data:IMPACT:Gain Privileges or Assume Identity:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Other:NOTE:This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.::",
          "DetectionMethods": "::METHOD:Black Box:DESCRIPTION:Credential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code.:EFFECTIVENESS:Moderate::METHOD:Automated Static Analysis:DESCRIPTION:Automated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods.::METHOD:Manual Static Analysis:DESCRIPTION:This weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the product, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed.::METHOD:Manual Dynamic Analysis:DESCRIPTION:For hard-coded credentials in incoming authentication: use monitoring tools that examine the product's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the product was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities \u0026 anomalies:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Network Sniffer Forced Path Execution:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction:EFFECTIVENESS:High::",
          "PotentialMitigations": "::PHASE:Architecture and Design:DESCRIPTION:For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7]. In Windows environments, the Encrypted File System (EFS) may provide some protection.::PHASE:Architecture and Design:DESCRIPTION:For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a first login mode that requires the user to enter a unique strong password or key.::PHASE:Architecture and Design:DESCRIPTION:If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.::PHASE:Architecture and Design:DESCRIPTION:For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash. Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.::PHASE:Architecture and Design:DESCRIPTION:For front-end to back-end connections: Three solutions are possible, although none are complete. The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals. Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access. Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.::",
          "ObservedExamples": "::REFERENCE:CVE-2022-29953:DESCRIPTION:Condition Monitor firmware has a maintenance interface with hard-coded credentials:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29953::REFERENCE:CVE-2022-29960:DESCRIPTION:Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29960::REFERENCE:CVE-2022-29964:DESCRIPTION:Distributed Control System (DCS) has hard-coded passwords for local shell access:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29964::REFERENCE:CVE-2022-30997:DESCRIPTION:Programmable Logic Controller (PLC) has a maintenance service that uses undocumented, hard-coded credentials:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30997::REFERENCE:CVE-2022-30314:DESCRIPTION:Firmware for a Safety Instrumented System (SIS) has hard-coded credentials for access to boot configuration:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30314::REFERENCE:CVE-2022-30271:DESCRIPTION:Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used in typical deployments:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30271::REFERENCE:CVE-2021-37555:DESCRIPTION:Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]:LINK:https://www.cve.org/CVERecord?id=CVE-2021-37555::REFERENCE:CVE-2012-3503:DESCRIPTION:Installation script has a hard-coded secret token value, allowing attackers to bypass authentication:LINK:https://www.cve.org/CVERecord?id=CVE-2012-3503::REFERENCE:CVE-2010-2772:DESCRIPTION:SCADA system uses a hard-coded password to protect back-end database containing authorization information, exploited by Stuxnet worm:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2772::REFERENCE:CVE-2010-2073:DESCRIPTION:FTP server library uses hard-coded usernames and passwords for three default accounts:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2073::REFERENCE:CVE-2010-1573:DESCRIPTION:Chain: Router firmware uses hard-coded username and password for access to debug functionality, which can be used to execute arbitrary code:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1573::REFERENCE:CVE-2008-2369:DESCRIPTION:Server uses hard-coded authentication key:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2369::REFERENCE:CVE-2008-0961:DESCRIPTION:Backup product uses hard-coded username and password, allowing attackers to bypass authentication via the RPC interface:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0961::REFERENCE:CVE-2008-1160:DESCRIPTION:Security appliance uses hard-coded password allowing attackers to gain root access:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1160::REFERENCE:CVE-2006-7142:DESCRIPTION:Drive encryption product stores hard-coded cryptographic keys for encrypted configuration files in executable programs:LINK:https://www.cve.org/CVERecord?id=CVE-2006-7142::REFERENCE:CVE-2005-3716:DESCRIPTION:VoIP product uses hard-coded public credentials that cannot be changed, which allows attackers to obtain sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3716::REFERENCE:CVE-2005-3803:DESCRIPTION:VoIP product uses hard coded public and private SNMP community strings that cannot be changed, which allows remote attackers to obtain sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3803::REFERENCE:CVE-2005-0496:DESCRIPTION:Backup product contains hard-coded credentials that effectively serve as a back door, which allows remote attackers to access the file system:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0496::",
          "TaxonomyMappings": "::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:MSC03-J:ENTRY NAME:Never hard code sensitive information::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-798::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 1.5::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 1.5::",
          "RelatedAttackPatterns": "::191::70::",
          "Notes": "::TYPE:Maintenance:NOTE:The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the Mapping CWE to 62443 subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.::"
        },
        "Link": "https://cwe.mitre.org/data/definitions/798.html"
      },
      "Rules": [
        {
          "Id": "generic-secret-key-credentials",
          "DisplayName": "generic-secret-key-credentials",
          "ShortDescription": "Generic secret key",
          "FullDescription": "Potential secret found inside code. This could be a security risk.",
          "Precision": "high",
          "ExtraData": {
            "defaultConfigurationLevel": "high",
            "remediationRecommendation": "Remove the hard-coded credentials from the code and use a secure secret management system.",
            "secretCategory": "Generic"
          }
        }
      ],
      "Instances": [
        {
          "Id": "12",
          "RuleId": "generic-secret-key-credentials",
          "AffectedArtifactIds": [
            "2"
          ],
          "Severity": "critical",
          "SourceLanguage": "python",
          "LocationDetails": [
            {
              "LineLocation": {
                "RelativePath": "app/main.py",
                "Start": 11,
                "StartChar": 9,
                "End": 11,
                "EndChar": 9
              },
              "TextSnippet": "Potential hardcoded credentials. The code snippet will not be displayed for security reasons.",
              "LastEdit": "32"
            }
          ],
          "ExtraData": {
            "message": "Potential secret found inside code. This could be a security risk. This secret resides in a public repository and should be addressed immediately.",
            "secret-category": "Generic",
            "secret-id": "generic-secret-key-credentials",
            "secret-title": "Generic Secret Key Credentials",
            "visibility": "public"
          },
          "Fingerprint": "E8A3233F83A76C50"
        }
      ]
    }
  ],
  "FixSuggestions": [
    {
      "Id": "9",
      "Info": {
        "Recommendations": [
          {
            "FixVersion": {
              "Type": "pep440",
              "Version": "2.3.2"
            },
            "Kind": "Minimal version with no known vulnerabilities"
          },
          {
            "FixVersion": {
              "Type": "pep440",
              "Version": "2.3.2"
            },
            "Kind": "Maximum version with no known vulnerabilities"
          }
        ],
        "VersionGraphInfo": {
          "NodeCnt": 2,
          "EdgeCnt": 1,
          "ExtraAthenaCalls": 1,
          "VersionGraph": [
            {
              "Version": "1.1.1",
              "Edges": [
                {
                  "Version": "2.3.2",
                  "Severity": "high",
                  "CVE": "CVE-2023-30861"
                }
              ]
            },
            {
              "Version": "2.3.2"
            }
          ]
        },
        "FixSuggestionInfoAsString": "\nSorted Version Graph for package pkg:pypi/flask@1.1.1\n  1.1.1 is vulnerable:\n    high       CVE-2023-30861       FixVersion= 2.3.2\n  2.3.2 is not vulnerable\n\nFix recommendations for package pkg:pypi/flask@1.1.1\n  2.3.2 is the minimal version with no known vulnerabilities\n  2.3.2 is the maximum version and it has no known vulnerabilities\n\nStats: the Version Graph has 2 versions (nodes) and 1 CVEs (edges) (diameter=1)\n\n"
      },
      "AffectedArtifactId": "3"
    },
    {
      "Id": "10",
      "Info": {
        "Recommendations": [
          {
            "FixVersion": {
              "Type": "pep440",
              "Version": "2.32.4"
            },
            "Kind": "Minimal version with no known vulnerabilities"
          },
          {
            "FixVersion": {
              "Type": "pep440",
              "Version": "2.32.4"
            },
            "Kind": "Maximum version with no known vulnerabilities"
          },
          {
            "FixVersion": {
              "Type": "pep440",
              "Version": "2.25.1"
            },
            "Kind": "Minimal version with no critical or high vulnerabilities"
          }
        ],
        "VersionGraphInfo": {
          "NodeCnt": 4,
          "EdgeCnt": 6,
          "ExtraAthenaCalls": 1,
          "VersionGraph": [
            {
              "Version": "2.25.1",
              "Edges": [
                {
                  "Version": "2.31.0",
                  "Severity": "medium",
                  "CVE": "CVE-2023-32681"
                },
                {
                  "Version": "2.32.0",
                  "Severity": "medium",
                  "CVE": "CVE-2024-35195"
                },
                {
                  "Version": "2.32.4",
                  "Severity": "medium",
                  "CVE": "CVE-2024-47081"
                }
              ]
            },
            {
              "Version": "2.31.0",
              "Edges": [
                {
                  "Version": "2.32.0",
                  "Severity": "medium",
                  "CVE": "CVE-2024-35195"
                },
                {
                  "Version": "2.32.4",
                  "Severity": "medium",
                  "CVE": "CVE-2024-47081"
                }
              ]
            },
            {
              "Version": "2.32.0",
              "Edges": [
                {
                  "Version": "2.32.4",
                  "Severity": "medium",
                  "CVE": "CVE-2024-47081"
                }
              ]
            },
            {
              "Version": "2.32.4"
            }
          ]
        },
        "FixSuggestionInfoAsString": "\nSorted Version Graph for package pkg:pypi/requests@2.25.1\n  2.25.1 is vulnerable:\n    medium     CVE-2023-32681       FixVersion= 2.31.0\n    medium     CVE-2024-35195       FixVersion= 2.32.0\n    medium     CVE-2024-47081       FixVersion= 2.32.4\n  2.31.0 is vulnerable:\n    medium     CVE-2024-35195       FixVersion= 2.32.0\n    medium     CVE-2024-47081       FixVersion= 2.32.4\n  2.32.0 is vulnerable:\n    medium     CVE-2024-47081       FixVersion= 2.32.4\n  2.32.4 is not vulnerable\n\nFix recommendations for package pkg:pypi/requests@2.25.1\n  2.32.4 is the minimal version with no known vulnerabilities\n  2.32.4 is the maximum version and it has no known vulnerabilities\n  2.25.1 is the minimal version with no critical or high vulnerabilities\n\nStats: the Version Graph has 4 versions (nodes) and 6 CVEs (edges) (diameter=1)\n\n"
      },
      "AffectedArtifactId": "4"
    }
  ],
  "LicenseDetails": [
    {
      "SPDXId": "Apache-2.0",
      "CanonicalSPDXId": "Apache-2.0",
      "Category": "notice",
      "SPDXInfo": {
        "reference": "https://spdx.org/licenses/Apache-2.0.html",
        "isDeprecatedLicenseId": false,
        "detailsUrl": "https://spdx.org/licenses/Apache-2.0.json",
        "referenceNumber": 418,
        "name": "Apache License 2.0",
        "licenseId": "Apache-2.0",
        "seeAlso": [
          "https://www.apache.org/licenses/LICENSE-2.0",
          "https://opensource.org/licenses/Apache-2.0"
        ],
        "isOsiApproved": true
      }
    },
    {
      "SPDXId": "BSD-3-Clause",
      "CanonicalSPDXId": "BSD-3-Clause",
      "Category": "notice",
      "SPDXInfo": {
        "reference": "https://spdx.org/licenses/BSD-3-Clause.html",
        "isDeprecatedLicenseId": false,
        "detailsUrl": "https://spdx.org/licenses/BSD-3-Clause.json",
        "referenceNumber": 258,
        "name": "BSD 3-Clause \"New\" or \"Revised\" License",
        "licenseId": "BSD-3-Clause",
        "seeAlso": [
          "https://opensource.org/licenses/BSD-3-Clause",
          "https://www.eclipse.org/org/documents/edl-v10.php"
        ],
        "isOsiApproved": true
      }
    }
  ]
}
